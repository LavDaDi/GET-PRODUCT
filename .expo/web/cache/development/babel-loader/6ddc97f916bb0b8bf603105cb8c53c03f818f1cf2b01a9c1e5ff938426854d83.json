{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport { PermissionStatus, createPermissionHook, EventEmitter, UnavailabilityError } from 'expo-modules-core';\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport MediaLibrary from \"./ExponentMediaLibrary\";\nvar eventEmitter = new EventEmitter(MediaLibrary);\nexport { PermissionStatus };\nfunction arrayize(item) {\n  if (Array.isArray(item)) {\n    return item;\n  }\n  return item ? [item] : [];\n}\nfunction getId(ref) {\n  if (typeof ref === 'string') {\n    return ref;\n  }\n  return ref ? ref.id : undefined;\n}\nfunction checkAssetIds(assetIds) {\n  if (assetIds.some(function (id) {\n    return !id || typeof id !== 'string';\n  })) {\n    throw new Error('Asset ID must be a string!');\n  }\n}\nfunction checkAlbumIds(albumIds) {\n  if (albumIds.some(function (id) {\n    return !id || typeof id !== 'string';\n  })) {\n    throw new Error('Album ID must be a string!');\n  }\n}\nfunction checkMediaType(mediaType) {\n  if (Object.values(MediaType).indexOf(mediaType) === -1) {\n    throw new Error(\"Invalid mediaType: \" + mediaType);\n  }\n}\nfunction checkSortBy(sortBy) {\n  if (Array.isArray(sortBy)) {\n    checkSortByKey(sortBy[0]);\n    if (typeof sortBy[1] !== 'boolean') {\n      throw new Error('Invalid sortBy array argument. Second item must be a boolean!');\n    }\n  } else {\n    checkSortByKey(sortBy);\n  }\n}\nfunction checkSortByKey(sortBy) {\n  if (Object.values(SortBy).indexOf(sortBy) === -1) {\n    throw new Error(\"Invalid sortBy key: \" + sortBy);\n  }\n}\nfunction dateToNumber(value) {\n  return value instanceof Date ? value.getTime() : value;\n}\nexport var MediaType = MediaLibrary.MediaType;\nexport var SortBy = MediaLibrary.SortBy;\nexport function isAvailableAsync() {\n  return _regeneratorRuntime.async(function isAvailableAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          return _context.abrupt(\"return\", !!MediaLibrary && 'getAssetsAsync' in MediaLibrary);\n        case 1:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function requestPermissionsAsync() {\n  var writeOnly,\n    _args2 = arguments;\n  return _regeneratorRuntime.async(function requestPermissionsAsync$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          writeOnly = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : false;\n          if (MediaLibrary.requestPermissionsAsync) {\n            _context2.next = 3;\n            break;\n          }\n          throw new UnavailabilityError('MediaLibrary', 'requestPermissionsAsync');\n        case 3:\n          _context2.next = 5;\n          return _regeneratorRuntime.awrap(MediaLibrary.requestPermissionsAsync(writeOnly));\n        case 5:\n          return _context2.abrupt(\"return\", _context2.sent);\n        case 6:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function getPermissionsAsync() {\n  var writeOnly,\n    _args3 = arguments;\n  return _regeneratorRuntime.async(function getPermissionsAsync$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          writeOnly = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : false;\n          if (MediaLibrary.getPermissionsAsync) {\n            _context3.next = 3;\n            break;\n          }\n          throw new UnavailabilityError('MediaLibrary', 'getPermissionsAsync');\n        case 3:\n          _context3.next = 5;\n          return _regeneratorRuntime.awrap(MediaLibrary.getPermissionsAsync(writeOnly));\n        case 5:\n          return _context3.abrupt(\"return\", _context3.sent);\n        case 6:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport var usePermissions = createPermissionHook({\n  getMethod: function getMethod(options) {\n    return getPermissionsAsync(options == null ? void 0 : options.writeOnly);\n  },\n  requestMethod: function requestMethod(options) {\n    return requestPermissionsAsync(options == null ? void 0 : options.writeOnly);\n  }\n});\nexport function presentPermissionsPickerAsync() {\n  return _regeneratorRuntime.async(function presentPermissionsPickerAsync$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          if (MediaLibrary.presentPermissionsPickerAsync) {\n            _context4.next = 2;\n            break;\n          }\n          throw new UnavailabilityError('MediaLibrary', 'presentPermissionsPickerAsync');\n        case 2:\n          _context4.next = 4;\n          return _regeneratorRuntime.awrap(MediaLibrary.presentPermissionsPickerAsync());\n        case 4:\n          return _context4.abrupt(\"return\", _context4.sent);\n        case 5:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function createAssetAsync(localUri) {\n  var asset;\n  return _regeneratorRuntime.async(function createAssetAsync$(_context5) {\n    while (1) {\n      switch (_context5.prev = _context5.next) {\n        case 0:\n          if (MediaLibrary.createAssetAsync) {\n            _context5.next = 2;\n            break;\n          }\n          throw new UnavailabilityError('MediaLibrary', 'createAssetAsync');\n        case 2:\n          if (!(!localUri || typeof localUri !== 'string')) {\n            _context5.next = 4;\n            break;\n          }\n          throw new Error('Invalid argument \"localUri\". It must be a string!');\n        case 4:\n          _context5.next = 6;\n          return _regeneratorRuntime.awrap(MediaLibrary.createAssetAsync(localUri));\n        case 6:\n          asset = _context5.sent;\n          if (!Array.isArray(asset)) {\n            _context5.next = 9;\n            break;\n          }\n          return _context5.abrupt(\"return\", asset[0]);\n        case 9:\n          return _context5.abrupt(\"return\", asset);\n        case 10:\n        case \"end\":\n          return _context5.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function saveToLibraryAsync(localUri) {\n  return _regeneratorRuntime.async(function saveToLibraryAsync$(_context6) {\n    while (1) {\n      switch (_context6.prev = _context6.next) {\n        case 0:\n          if (MediaLibrary.saveToLibraryAsync) {\n            _context6.next = 2;\n            break;\n          }\n          throw new UnavailabilityError('MediaLibrary', 'saveToLibraryAsync');\n        case 2:\n          _context6.next = 4;\n          return _regeneratorRuntime.awrap(MediaLibrary.saveToLibraryAsync(localUri));\n        case 4:\n          return _context6.abrupt(\"return\", _context6.sent);\n        case 5:\n        case \"end\":\n          return _context6.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function addAssetsToAlbumAsync(assets, album) {\n  var copy,\n    assetIds,\n    albumId,\n    _args7 = arguments;\n  return _regeneratorRuntime.async(function addAssetsToAlbumAsync$(_context7) {\n    while (1) {\n      switch (_context7.prev = _context7.next) {\n        case 0:\n          copy = _args7.length > 2 && _args7[2] !== undefined ? _args7[2] : true;\n          if (MediaLibrary.addAssetsToAlbumAsync) {\n            _context7.next = 3;\n            break;\n          }\n          throw new UnavailabilityError('MediaLibrary', 'addAssetsToAlbumAsync');\n        case 3:\n          assetIds = arrayize(assets).map(getId);\n          albumId = getId(album);\n          checkAssetIds(assetIds);\n          if (!(!albumId || typeof albumId !== 'string')) {\n            _context7.next = 8;\n            break;\n          }\n          throw new Error('Invalid album ID. It must be a string!');\n        case 8:\n          if (!(Platform.OS === 'ios')) {\n            _context7.next = 12;\n            break;\n          }\n          _context7.next = 11;\n          return _regeneratorRuntime.awrap(MediaLibrary.addAssetsToAlbumAsync(assetIds, albumId));\n        case 11:\n          return _context7.abrupt(\"return\", _context7.sent);\n        case 12:\n          _context7.next = 14;\n          return _regeneratorRuntime.awrap(MediaLibrary.addAssetsToAlbumAsync(assetIds, albumId, !!copy));\n        case 14:\n          return _context7.abrupt(\"return\", _context7.sent);\n        case 15:\n        case \"end\":\n          return _context7.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function removeAssetsFromAlbumAsync(assets, album) {\n  var assetIds, albumId;\n  return _regeneratorRuntime.async(function removeAssetsFromAlbumAsync$(_context8) {\n    while (1) {\n      switch (_context8.prev = _context8.next) {\n        case 0:\n          if (MediaLibrary.removeAssetsFromAlbumAsync) {\n            _context8.next = 2;\n            break;\n          }\n          throw new UnavailabilityError('MediaLibrary', 'removeAssetsFromAlbumAsync');\n        case 2:\n          assetIds = arrayize(assets).map(getId);\n          albumId = getId(album);\n          checkAssetIds(assetIds);\n          _context8.next = 7;\n          return _regeneratorRuntime.awrap(MediaLibrary.removeAssetsFromAlbumAsync(assetIds, albumId));\n        case 7:\n          return _context8.abrupt(\"return\", _context8.sent);\n        case 8:\n        case \"end\":\n          return _context8.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function deleteAssetsAsync(assets) {\n  var assetIds;\n  return _regeneratorRuntime.async(function deleteAssetsAsync$(_context9) {\n    while (1) {\n      switch (_context9.prev = _context9.next) {\n        case 0:\n          if (MediaLibrary.deleteAssetsAsync) {\n            _context9.next = 2;\n            break;\n          }\n          throw new UnavailabilityError('MediaLibrary', 'deleteAssetsAsync');\n        case 2:\n          assetIds = arrayize(assets).map(getId);\n          checkAssetIds(assetIds);\n          _context9.next = 6;\n          return _regeneratorRuntime.awrap(MediaLibrary.deleteAssetsAsync(assetIds));\n        case 6:\n          return _context9.abrupt(\"return\", _context9.sent);\n        case 7:\n        case \"end\":\n          return _context9.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function getAssetInfoAsync(asset) {\n  var options,\n    assetId,\n    assetInfo,\n    _args10 = arguments;\n  return _regeneratorRuntime.async(function getAssetInfoAsync$(_context10) {\n    while (1) {\n      switch (_context10.prev = _context10.next) {\n        case 0:\n          options = _args10.length > 1 && _args10[1] !== undefined ? _args10[1] : {\n            shouldDownloadFromNetwork: true\n          };\n          if (MediaLibrary.getAssetInfoAsync) {\n            _context10.next = 3;\n            break;\n          }\n          throw new UnavailabilityError('MediaLibrary', 'getAssetInfoAsync');\n        case 3:\n          assetId = getId(asset);\n          checkAssetIds([assetId]);\n          _context10.next = 7;\n          return _regeneratorRuntime.awrap(MediaLibrary.getAssetInfoAsync(assetId, options));\n        case 7:\n          assetInfo = _context10.sent;\n          if (!Array.isArray(assetInfo)) {\n            _context10.next = 10;\n            break;\n          }\n          return _context10.abrupt(\"return\", assetInfo[0]);\n        case 10:\n          return _context10.abrupt(\"return\", assetInfo);\n        case 11:\n        case \"end\":\n          return _context10.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function getAlbumsAsync() {\n  var _ref,\n    _ref$includeSmartAlbu,\n    includeSmartAlbums,\n    _args11 = arguments;\n  return _regeneratorRuntime.async(function getAlbumsAsync$(_context11) {\n    while (1) {\n      switch (_context11.prev = _context11.next) {\n        case 0:\n          _ref = _args11.length > 0 && _args11[0] !== undefined ? _args11[0] : {}, _ref$includeSmartAlbu = _ref.includeSmartAlbums, includeSmartAlbums = _ref$includeSmartAlbu === void 0 ? false : _ref$includeSmartAlbu;\n          if (MediaLibrary.getAlbumsAsync) {\n            _context11.next = 3;\n            break;\n          }\n          throw new UnavailabilityError('MediaLibrary', 'getAlbumsAsync');\n        case 3:\n          _context11.next = 5;\n          return _regeneratorRuntime.awrap(MediaLibrary.getAlbumsAsync({\n            includeSmartAlbums: includeSmartAlbums\n          }));\n        case 5:\n          return _context11.abrupt(\"return\", _context11.sent);\n        case 6:\n        case \"end\":\n          return _context11.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function getAlbumAsync(title) {\n  return _regeneratorRuntime.async(function getAlbumAsync$(_context12) {\n    while (1) {\n      switch (_context12.prev = _context12.next) {\n        case 0:\n          if (MediaLibrary.getAlbumAsync) {\n            _context12.next = 2;\n            break;\n          }\n          throw new UnavailabilityError('MediaLibrary', 'getAlbumAsync');\n        case 2:\n          if (!(typeof title !== 'string')) {\n            _context12.next = 4;\n            break;\n          }\n          throw new Error('Album title must be a string!');\n        case 4:\n          _context12.next = 6;\n          return _regeneratorRuntime.awrap(MediaLibrary.getAlbumAsync(title));\n        case 6:\n          return _context12.abrupt(\"return\", _context12.sent);\n        case 7:\n        case \"end\":\n          return _context12.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function createAlbumAsync(albumName, asset) {\n  var copyAsset,\n    assetId,\n    _args13 = arguments;\n  return _regeneratorRuntime.async(function createAlbumAsync$(_context13) {\n    while (1) {\n      switch (_context13.prev = _context13.next) {\n        case 0:\n          copyAsset = _args13.length > 2 && _args13[2] !== undefined ? _args13[2] : true;\n          if (MediaLibrary.createAlbumAsync) {\n            _context13.next = 3;\n            break;\n          }\n          throw new UnavailabilityError('MediaLibrary', 'createAlbumAsync');\n        case 3:\n          assetId = getId(asset);\n          if (!(Platform.OS === 'android' && (typeof assetId !== 'string' || assetId.length === 0))) {\n            _context13.next = 6;\n            break;\n          }\n          throw new Error('MediaLibrary.createAlbumAsync must be called with an asset on Android.');\n        case 6:\n          if (!(!albumName || typeof albumName !== 'string')) {\n            _context13.next = 8;\n            break;\n          }\n          throw new Error('Invalid argument \"albumName\". It must be a string!');\n        case 8:\n          if (!(assetId != null && typeof assetId !== 'string')) {\n            _context13.next = 10;\n            break;\n          }\n          throw new Error('Asset ID must be a string!');\n        case 10:\n          if (!(Platform.OS === 'ios')) {\n            _context13.next = 14;\n            break;\n          }\n          _context13.next = 13;\n          return _regeneratorRuntime.awrap(MediaLibrary.createAlbumAsync(albumName, assetId));\n        case 13:\n          return _context13.abrupt(\"return\", _context13.sent);\n        case 14:\n          _context13.next = 16;\n          return _regeneratorRuntime.awrap(MediaLibrary.createAlbumAsync(albumName, assetId, !!copyAsset));\n        case 16:\n          return _context13.abrupt(\"return\", _context13.sent);\n        case 17:\n        case \"end\":\n          return _context13.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function deleteAlbumsAsync(albums) {\n  var assetRemove,\n    albumIds,\n    _args14 = arguments;\n  return _regeneratorRuntime.async(function deleteAlbumsAsync$(_context14) {\n    while (1) {\n      switch (_context14.prev = _context14.next) {\n        case 0:\n          assetRemove = _args14.length > 1 && _args14[1] !== undefined ? _args14[1] : false;\n          if (MediaLibrary.deleteAlbumsAsync) {\n            _context14.next = 3;\n            break;\n          }\n          throw new UnavailabilityError('MediaLibrary', 'deleteAlbumsAsync');\n        case 3:\n          albumIds = arrayize(albums).map(getId);\n          checkAlbumIds(albumIds);\n          if (!(Platform.OS === 'android')) {\n            _context14.next = 9;\n            break;\n          }\n          _context14.next = 8;\n          return _regeneratorRuntime.awrap(MediaLibrary.deleteAlbumsAsync(albumIds));\n        case 8:\n          return _context14.abrupt(\"return\", _context14.sent);\n        case 9:\n          _context14.next = 11;\n          return _regeneratorRuntime.awrap(MediaLibrary.deleteAlbumsAsync(albumIds, !!assetRemove));\n        case 11:\n          return _context14.abrupt(\"return\", _context14.sent);\n        case 12:\n        case \"end\":\n          return _context14.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function getAssetsAsync() {\n  var assetsOptions,\n    first,\n    after,\n    album,\n    sortBy,\n    mediaType,\n    createdAfter,\n    createdBefore,\n    options,\n    _args15 = arguments;\n  return _regeneratorRuntime.async(function getAssetsAsync$(_context15) {\n    while (1) {\n      switch (_context15.prev = _context15.next) {\n        case 0:\n          assetsOptions = _args15.length > 0 && _args15[0] !== undefined ? _args15[0] : {};\n          if (MediaLibrary.getAssetsAsync) {\n            _context15.next = 3;\n            break;\n          }\n          throw new UnavailabilityError('MediaLibrary', 'getAssetsAsync');\n        case 3:\n          first = assetsOptions.first, after = assetsOptions.after, album = assetsOptions.album, sortBy = assetsOptions.sortBy, mediaType = assetsOptions.mediaType, createdAfter = assetsOptions.createdAfter, createdBefore = assetsOptions.createdBefore;\n          options = {\n            first: first == null ? 20 : first,\n            after: getId(after),\n            album: getId(album),\n            sortBy: arrayize(sortBy),\n            mediaType: arrayize(mediaType || [MediaType.photo]),\n            createdAfter: dateToNumber(createdAfter),\n            createdBefore: dateToNumber(createdBefore)\n          };\n          if (!(first != null && typeof options.first !== 'number')) {\n            _context15.next = 7;\n            break;\n          }\n          throw new Error('Option \"first\" must be a number!');\n        case 7:\n          if (!(after != null && typeof options.after !== 'string')) {\n            _context15.next = 9;\n            break;\n          }\n          throw new Error('Option \"after\" must be a string!');\n        case 9:\n          if (!(album != null && typeof options.album !== 'string')) {\n            _context15.next = 11;\n            break;\n          }\n          throw new Error('Option \"album\" must be a string!');\n        case 11:\n          if (!(after != null && Platform.OS === 'android' && isNaN(parseInt(getId(after), 10)))) {\n            _context15.next = 13;\n            break;\n          }\n          throw new Error('Option \"after\" must be a valid ID!');\n        case 13:\n          if (!(first != null && first < 0)) {\n            _context15.next = 15;\n            break;\n          }\n          throw new Error('Option \"first\" must be a positive integer!');\n        case 15:\n          options.sortBy.forEach(checkSortBy);\n          options.mediaType.forEach(checkMediaType);\n          _context15.next = 19;\n          return _regeneratorRuntime.awrap(MediaLibrary.getAssetsAsync(options));\n        case 19:\n          return _context15.abrupt(\"return\", _context15.sent);\n        case 20:\n        case \"end\":\n          return _context15.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function addListener(listener) {\n  return eventEmitter.addListener(MediaLibrary.CHANGE_LISTENER_NAME, listener);\n}\nexport function removeSubscription(subscription) {\n  subscription.remove();\n}\nexport function removeAllListeners() {\n  eventEmitter.removeAllListeners(MediaLibrary.CHANGE_LISTENER_NAME);\n}\nexport function getMomentsAsync() {\n  return _regeneratorRuntime.async(function getMomentsAsync$(_context16) {\n    while (1) {\n      switch (_context16.prev = _context16.next) {\n        case 0:\n          if (MediaLibrary.getMomentsAsync) {\n            _context16.next = 2;\n            break;\n          }\n          throw new UnavailabilityError('MediaLibrary', 'getMomentsAsync');\n        case 2:\n          _context16.next = 4;\n          return _regeneratorRuntime.awrap(MediaLibrary.getMomentsAsync());\n        case 4:\n          return _context16.abrupt(\"return\", _context16.sent);\n        case 5:\n        case \"end\":\n          return _context16.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function migrateAlbumIfNeededAsync(album) {\n  return _regeneratorRuntime.async(function migrateAlbumIfNeededAsync$(_context17) {\n    while (1) {\n      switch (_context17.prev = _context17.next) {\n        case 0:\n          if (MediaLibrary.migrateAlbumIfNeededAsync) {\n            _context17.next = 2;\n            break;\n          }\n          return _context17.abrupt(\"return\");\n        case 2:\n          _context17.next = 4;\n          return _regeneratorRuntime.awrap(MediaLibrary.migrateAlbumIfNeededAsync(getId(album)));\n        case 4:\n          return _context17.abrupt(\"return\", _context17.sent);\n        case 5:\n        case \"end\":\n          return _context17.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function albumNeedsMigrationAsync(album) {\n  return _regeneratorRuntime.async(function albumNeedsMigrationAsync$(_context18) {\n    while (1) {\n      switch (_context18.prev = _context18.next) {\n        case 0:\n          if (MediaLibrary.albumNeedsMigrationAsync) {\n            _context18.next = 2;\n            break;\n          }\n          return _context18.abrupt(\"return\", false);\n        case 2:\n          _context18.next = 4;\n          return _regeneratorRuntime.awrap(MediaLibrary.albumNeedsMigrationAsync(getId(album)));\n        case 4:\n          return _context18.abrupt(\"return\", _context18.sent);\n        case 5:\n        case \"end\":\n          return _context18.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}","map":{"version":3,"names":["PermissionStatus","createPermissionHook","EventEmitter","UnavailabilityError","Platform","MediaLibrary","eventEmitter","arrayize","item","Array","isArray","getId","ref","id","undefined","checkAssetIds","assetIds","some","Error","checkAlbumIds","albumIds","checkMediaType","mediaType","Object","values","MediaType","indexOf","checkSortBy","sortBy","checkSortByKey","SortBy","dateToNumber","value","Date","getTime","isAvailableAsync","_regeneratorRuntime","async","isAvailableAsync$","_context","prev","next","abrupt","stop","Promise","requestPermissionsAsync","writeOnly","_args2","arguments","requestPermissionsAsync$","_context2","length","awrap","sent","getPermissionsAsync","_args3","getPermissionsAsync$","_context3","usePermissions","getMethod","options","requestMethod","presentPermissionsPickerAsync","presentPermissionsPickerAsync$","_context4","createAssetAsync","localUri","asset","createAssetAsync$","_context5","saveToLibraryAsync","saveToLibraryAsync$","_context6","addAssetsToAlbumAsync","assets","album","copy","albumId","_args7","addAssetsToAlbumAsync$","_context7","map","OS","removeAssetsFromAlbumAsync","removeAssetsFromAlbumAsync$","_context8","deleteAssetsAsync","deleteAssetsAsync$","_context9","getAssetInfoAsync","assetId","assetInfo","_args10","getAssetInfoAsync$","_context10","shouldDownloadFromNetwork","getAlbumsAsync","_ref","_ref$includeSmartAlbu","includeSmartAlbums","_args11","getAlbumsAsync$","_context11","getAlbumAsync","title","getAlbumAsync$","_context12","createAlbumAsync","albumName","copyAsset","_args13","createAlbumAsync$","_context13","deleteAlbumsAsync","albums","assetRemove","_args14","deleteAlbumsAsync$","_context14","getAssetsAsync","assetsOptions","first","after","createdAfter","createdBefore","_args15","getAssetsAsync$","_context15","photo","isNaN","parseInt","forEach","addListener","listener","CHANGE_LISTENER_NAME","removeSubscription","subscription","remove","removeAllListeners","getMomentsAsync","getMomentsAsync$","_context16","migrateAlbumIfNeededAsync","migrateAlbumIfNeededAsync$","_context17","albumNeedsMigrationAsync","albumNeedsMigrationAsync$","_context18"],"sources":["D:\\programming\\apper\\camera-app\\node_modules\\expo-media-library\\src\\MediaLibrary.ts"],"sourcesContent":["import {\n  PermissionResponse as EXPermissionResponse,\n  PermissionStatus,\n  PermissionExpiration,\n  PermissionHookOptions,\n  createPermissionHook,\n  EventEmitter,\n  Subscription,\n  UnavailabilityError,\n} from 'expo-modules-core';\nimport { Platform } from 'react-native';\n\nimport MediaLibrary from './ExponentMediaLibrary';\n\nconst eventEmitter = new EventEmitter(MediaLibrary);\n\n// @needsAudit\nexport type PermissionResponse = EXPermissionResponse & {\n  /**\n   * Indicates if your app has access to the whole or only part of the photo library. Possible values are:\n   * - `'all'` if the user granted your app access to the whole photo library\n   * - `'limited'` if the user granted your app access only to selected photos (only available on iOS 14.0+)\n   * - `'none'` if user denied or hasn't yet granted the permission\n   */\n  accessPrivileges?: 'all' | 'limited' | 'none';\n};\n\nexport type MediaTypeValue = 'audio' | 'photo' | 'video' | 'unknown';\nexport type SortByKey =\n  | 'default'\n  | 'mediaType'\n  | 'width'\n  | 'height'\n  | 'creationTime'\n  | 'modificationTime'\n  | 'duration';\nexport type SortByValue = [SortByKey, boolean] | SortByKey;\n\nexport type MediaTypeObject = {\n  audio: 'audio';\n  photo: 'photo';\n  video: 'video';\n  unknown: 'unknown';\n};\n\nexport type SortByObject = {\n  default: 'default';\n  mediaType: 'mediaType';\n  width: 'width';\n  height: 'height';\n  creationTime: 'creationTime';\n  modificationTime: 'modificationTime';\n  duration: 'duration';\n};\n\n// @needsAudit\nexport type Asset = {\n  /**\n   * Internal ID that represents an asset.\n   */\n  id: string;\n  /**\n   * Filename of the asset.\n   */\n  filename: string;\n  /**\n   * URI that points to the asset. `assets://*` (iOS), `file://*` (Android)\n   */\n  uri: string;\n  /**\n   * Media type.\n   */\n  mediaType: MediaTypeValue;\n  /**\n   * An array of media subtypes.\n   * @platform ios\n   */\n  mediaSubtypes?: MediaSubtype[];\n  /**\n   * Width of the image or video.\n   */\n  width: number;\n  /**\n   * Height of the image or video.\n   */\n  height: number;\n  /**\n   * File creation timestamp.\n   */\n  creationTime: number;\n  /**\n   * Last modification timestamp.\n   */\n  modificationTime: number;\n  /**\n   * Duration of the video or audio asset in seconds.\n   */\n  duration: number;\n  /**\n   * Album ID that the asset belongs to.\n   * @platform android\n   */\n  albumId?: string;\n};\n\n// @needsAudit\nexport type AssetInfo = Asset & {\n  /**\n   * Local URI for the asset.\n   */\n  localUri?: string;\n  /**\n   * GPS location if available.\n   */\n  location?: Location;\n  /**\n   * EXIF metadata associated with the image.\n   */\n  exif?: object;\n  /**\n   * Whether the asset is marked as favorite.\n   * @platform ios\n   */\n  isFavorite?: boolean;\n  /**\n   * This field is available only if flag `shouldDownloadFromNetwork` is set to `false`.\n   * Whether the asset is stored on the network (iCloud on iOS).\n   * @platform ios\n   */\n  isNetworkAsset?: boolean; //iOS only\n  /**\n   * Display orientation of the image. Orientation is available only for assets whose\n   * `mediaType` is `MediaType.photo`. Value will range from 1 to 8, see [EXIF orientation specification](http://sylvana.net/jpegcrop/exif_orientation.html)\n   * for more details.\n   * @platform ios\n   */\n  orientation?: number;\n};\n\n// @docsMissing\nexport type MediaSubtype =\n  | 'depthEffect'\n  | 'hdr'\n  | 'highFrameRate'\n  | 'livePhoto'\n  | 'panorama'\n  | 'screenshot'\n  | 'stream'\n  | 'timelapse';\n\n// @needsAudit\nexport type MediaLibraryAssetInfoQueryOptions = {\n  /**\n   * Whether allow the asset to be downloaded from network. Only available in iOS with iCloud assets.\n   * @default `true`\n   */\n  shouldDownloadFromNetwork?: boolean;\n};\n\n// @needsAudit\nexport type MediaLibraryAssetsChangeEvent = {\n  /**\n   * Whether the media library's changes could be described as \"incremental changes\".\n   * `true` indicates the changes are described by the `insertedAssets`, `deletedAssets` and\n   * `updatedAssets` values. `false` indicates that the scope of changes is too large and you\n   * should perform a full assets reload (eg. a user has changed access to individual assets in the\n   * media library).\n   */\n  hasIncrementalChanges: boolean;\n  /**\n   * Available only if `hasIncrementalChanges` is `true`.\n   * Array of [`Asset`](#asset)s that have been inserted to the library.\n   */\n  insertedAssets?: Asset[];\n  /**\n   * Available only if `hasIncrementalChanges` is `true`.\n   * Array of [`Asset`](#asset)s that have been deleted from the library.\n   */\n  deletedAssets?: Asset[];\n  /**\n   * Available only if `hasIncrementalChanges` is `true`.\n   * Array of [`Asset`](#asset)s that have been updated or completed downloading from network\n   * storage (iCloud on iOS).\n   */\n  updatedAssets?: Asset[];\n};\n\n// @docsMissing\nexport type Location = {\n  latitude: number;\n  longitude: number;\n};\n\n// @needsAudit\nexport type Album = {\n  /**\n   * Album ID.\n   */\n  id: string;\n  /**\n   * Album title.\n   */\n  title: string;\n  /**\n   * Estimated number of assets in the album.\n   */\n  assetCount: number;\n  /**\n   * The type of the assets album.\n   * @platform ios\n   */\n  type?: AlbumType;\n  /**\n   * Apply only to albums whose type is `'moment'`. Earliest creation timestamp of all\n   * assets in the moment.\n   * @platform ios\n   */\n  startTime: number;\n  /**\n   * Apply only to albums whose type is `'moment'`. Latest creation timestamp of all\n   * assets in the moment.\n   * @platform ios\n   */\n  endTime: number;\n  /**\n   * Apply only to albums whose type is `'moment'`. Approximated location of all\n   * assets in the moment.\n   * @platform ios\n   */\n  approximateLocation?: Location;\n  /**\n   * Apply only to albums whose type is `'moment'`. Names of locations grouped\n   * in the moment.\n   * @platform ios\n   */\n  locationNames?: string[];\n};\n\n// @docsMissing\nexport type AlbumType = 'album' | 'moment' | 'smartAlbum';\n\n// @docsMissing\nexport type AlbumsOptions = {\n  includeSmartAlbums?: boolean;\n};\n\n// @needsAudit\nexport type AssetsOptions = {\n  /**\n   * The maximum number of items on a single page.\n   * @default `20`\n   */\n  first?: number;\n  /**\n   * Asset ID of the last item returned on the previous page.\n   */\n  after?: AssetRef;\n  /**\n   * [Album](#album) or its ID to get assets from specific album.\n   */\n  album?: AlbumRef;\n  /**\n   * An array of [`SortByValue`](#sortbyvalue)s or a single `SortByValue` value. By default, all\n   * keys are sorted in descending order, however you can also pass a pair `[key, ascending]` where\n   * the second item is a `boolean` value that means whether to use ascending order. Note that if\n   * the `SortBy.default` key is used, then `ascending` argument will not matter. Earlier items have\n   * higher priority when sorting out the results.\n   * If empty, this method will use the default sorting that is provided by the platform.\n   */\n  sortBy?: SortByValue[] | SortByValue;\n  /**\n   * An array of [MediaTypeValue](#expomedialibrarymediatypevalue)s or a single `MediaTypeValue`.\n   * @default `MediaType.photo`\n   */\n  mediaType?: MediaTypeValue[] | MediaTypeValue;\n  /**\n   * `Date` object or Unix timestamp in milliseconds limiting returned assets only to those that\n   * were created after this date.\n   */\n  createdAfter?: Date | number;\n  /**\n   * Similarly as `createdAfter`, but limits assets only to those that were created before specified\n   * date.\n   */\n  createdBefore?: Date | number;\n};\n\n// @needsAudit\nexport type PagedInfo<T> = {\n  /**\n   * A page of [`Asset`](#asset)s fetched by the query.\n   */\n  assets: T[];\n  /**\n   * ID of the last fetched asset. It should be passed as `after` option in order to get the\n   * next page.\n   */\n  endCursor: string;\n  /**\n   * Whether there are more assets to fetch.\n   */\n  hasNextPage: boolean;\n  /**\n   * Estimated total number of assets that match the query.\n   */\n  totalCount: number;\n};\n\n// @docsMissing\nexport type AssetRef = Asset | string;\n\n// @docsMissing\nexport type AlbumRef = Album | string;\n\nexport {\n  PermissionStatus,\n  PermissionExpiration,\n  EXPermissionResponse,\n  PermissionHookOptions,\n  Subscription,\n};\n\nfunction arrayize(item: any): any[] {\n  if (Array.isArray(item)) {\n    return item;\n  }\n  return item ? [item] : [];\n}\n\nfunction getId(ref: any): string | undefined {\n  if (typeof ref === 'string') {\n    return ref;\n  }\n  return ref ? ref.id : undefined;\n}\n\nfunction checkAssetIds(assetIds: any): void {\n  if (assetIds.some((id) => !id || typeof id !== 'string')) {\n    throw new Error('Asset ID must be a string!');\n  }\n}\n\nfunction checkAlbumIds(albumIds: any): void {\n  if (albumIds.some((id) => !id || typeof id !== 'string')) {\n    throw new Error('Album ID must be a string!');\n  }\n}\n\nfunction checkMediaType(mediaType: any): void {\n  if (Object.values(MediaType).indexOf(mediaType) === -1) {\n    throw new Error(`Invalid mediaType: ${mediaType}`);\n  }\n}\n\nfunction checkSortBy(sortBy: any): void {\n  if (Array.isArray(sortBy)) {\n    checkSortByKey(sortBy[0]);\n\n    if (typeof sortBy[1] !== 'boolean') {\n      throw new Error('Invalid sortBy array argument. Second item must be a boolean!');\n    }\n  } else {\n    checkSortByKey(sortBy);\n  }\n}\n\nfunction checkSortByKey(sortBy: any): void {\n  if (Object.values(SortBy).indexOf(sortBy) === -1) {\n    throw new Error(`Invalid sortBy key: ${sortBy}`);\n  }\n}\n\nfunction dateToNumber(value?: Date | number): number | undefined {\n  return value instanceof Date ? value.getTime() : value;\n}\n\n// @needsAudit\n/**\n * Possible media types.\n */\nexport const MediaType: MediaTypeObject = MediaLibrary.MediaType;\n\n// @needsAudit\n/**\n * Supported keys that can be used to sort `getAssetsAsync` results.\n */\nexport const SortBy: SortByObject = MediaLibrary.SortBy;\n\n// @needsAudit\n/**\n * Returns whether the Media Library API is enabled on the current device.\n * @return A promise which fulfils with a `boolean`, indicating whether the Media Library API is\n * available on the current device.\n */\nexport async function isAvailableAsync(): Promise<boolean> {\n  return !!MediaLibrary && 'getAssetsAsync' in MediaLibrary;\n}\n\n// @needsAudit @docsMissing\n/**\n * Asks the user to grant permissions for accessing media in user's media library.\n * @param writeOnly\n * @return A promise that fulfils with [`PermissionResponse`](#permissionresponse) object.\n */\nexport async function requestPermissionsAsync(\n  writeOnly: boolean = false\n): Promise<PermissionResponse> {\n  if (!MediaLibrary.requestPermissionsAsync) {\n    throw new UnavailabilityError('MediaLibrary', 'requestPermissionsAsync');\n  }\n  return await MediaLibrary.requestPermissionsAsync(writeOnly);\n}\n\n// @needsAudit @docsMissing\n/**\n * Checks user's permissions for accessing media library.\n * @param writeOnly\n * @return A promise that fulfils with [`PermissionResponse`](#permissionresponse) object.\n */\nexport async function getPermissionsAsync(writeOnly: boolean = false): Promise<PermissionResponse> {\n  if (!MediaLibrary.getPermissionsAsync) {\n    throw new UnavailabilityError('MediaLibrary', 'getPermissionsAsync');\n  }\n  return await MediaLibrary.getPermissionsAsync(writeOnly);\n}\n\n// @needsAudit\n/**\n * Check or request permissions to access the media library.\n * This uses both `requestPermissionsAsync` and `getPermissionsAsync` to interact with the permissions.\n *\n * @example\n * ```ts\n * const [status, requestPermission] = MediaLibrary.usePermissions();\n * ```\n */\nexport const usePermissions = createPermissionHook<PermissionResponse, { writeOnly?: boolean }>({\n  // TODO(cedric): permission requesters should have an options param or a different requester\n  getMethod: (options) => getPermissionsAsync(options?.writeOnly),\n  requestMethod: (options) => requestPermissionsAsync(options?.writeOnly),\n});\n\n// @needsAudit\n/**\n * __Available only on iOS >= 14.__ Allows the user to update the assets that your app has access to.\n * The system modal is only displayed if the user originally allowed only `limited` access to their\n * media library, otherwise this method is a no-op.\n * @return A promise that either rejects if the method is unavailable (meaning the device is not\n * running iOS >= 14), or resolves to `void`.\n * > __Note:__ This method doesn't inform you if the user changes which assets your app has access to.\n * For that information, you need to subscribe for updates to the user's media library using [addListener(listener)](#medialibraryaddlistenerlistener).\n * If `hasIncrementalChanges` is `false`, the user changed their permissions.\n */\nexport async function presentPermissionsPickerAsync(): Promise<void> {\n  if (!MediaLibrary.presentPermissionsPickerAsync) {\n    throw new UnavailabilityError('MediaLibrary', 'presentPermissionsPickerAsync');\n  }\n  return await MediaLibrary.presentPermissionsPickerAsync();\n}\n\n// @needsAudit\n/**\n * Creates an asset from existing file. The most common use case is to save a picture taken by [Camera](../camera).\n * This method requires `CAMERA_ROLL` permission.\n *\n * @example\n * ```js\n * const { uri } = await Camera.takePictureAsync();\n * const asset = await MediaLibrary.createAssetAsync(uri);\n * ```\n * @param localUri A URI to the image or video file. It must contain an extension. On Android it\n * must be a local path, so it must start with `file:///`\n * @return A promise which fulfils with an object representing an [`Asset`](#asset).\n */\nexport async function createAssetAsync(localUri: string): Promise<Asset> {\n  if (!MediaLibrary.createAssetAsync) {\n    throw new UnavailabilityError('MediaLibrary', 'createAssetAsync');\n  }\n\n  if (!localUri || typeof localUri !== 'string') {\n    throw new Error('Invalid argument \"localUri\". It must be a string!');\n  }\n  const asset = await MediaLibrary.createAssetAsync(localUri);\n\n  if (Array.isArray(asset)) {\n    // Android returns an array with asset, we need to pick the first item\n    return asset[0];\n  }\n  return asset;\n}\n\n// @needsAudit\n/**\n * Saves the file at given `localUri` to the user's media library. Unlike [`createAssetAsync()`](#medialibrarycreateassetasynclocaluri),\n * This method doesn't return created asset.\n * On __iOS 11+__, it's possible to use this method without asking for `CAMERA_ROLL` permission,\n * however then yours `Info.plist` should have `NSPhotoLibraryAddUsageDescription` key.\n * @param localUri A URI to the image or video file. It must contain an extension. On Android it\n * must be a local path, so it must start with `file:///`.\n */\nexport async function saveToLibraryAsync(localUri: string): Promise<void> {\n  if (!MediaLibrary.saveToLibraryAsync) {\n    throw new UnavailabilityError('MediaLibrary', 'saveToLibraryAsync');\n  }\n  return await MediaLibrary.saveToLibraryAsync(localUri);\n}\n\n// @needsAudit\n/**\n * Adds array of assets to the album.\n *\n * On Android, by default it copies assets from the current album to provided one, however it's also\n * possible to move them by passing `false` as `copyAssets` argument.In case they're copied you\n * should keep in mind that `getAssetsAsync` will return duplicated assets.\n * @param assets An array of [Asset](#asset) or their IDs.\n * @param album An [Album](#album) or its ID.\n * @param copy __Android only.__ Whether to copy assets to the new album instead of move them.\n * Defaults to `true`.\n * @return Returns promise which fulfils with `true` if the assets were successfully added to\n * the album.\n */\nexport async function addAssetsToAlbumAsync(\n  assets: AssetRef[] | AssetRef,\n  album: AlbumRef,\n  copy: boolean = true\n): Promise<boolean> {\n  if (!MediaLibrary.addAssetsToAlbumAsync) {\n    throw new UnavailabilityError('MediaLibrary', 'addAssetsToAlbumAsync');\n  }\n\n  const assetIds = arrayize(assets).map(getId);\n  const albumId = getId(album);\n\n  checkAssetIds(assetIds);\n\n  if (!albumId || typeof albumId !== 'string') {\n    throw new Error('Invalid album ID. It must be a string!');\n  }\n\n  if (Platform.OS === 'ios') {\n    return await MediaLibrary.addAssetsToAlbumAsync(assetIds, albumId);\n  }\n  return await MediaLibrary.addAssetsToAlbumAsync(assetIds, albumId, !!copy);\n}\n\n// @needsAudit\n/**\n * Removes given assets from album.\n *\n * On Android, album will be automatically deleted if there are no more assets inside.\n * @param assets An array of [Asset](#asset) or their IDs.\n * @param album An [Album](#album) or its ID.\n * @return Returns promise which fulfils with `true` if the assets were successfully removed from\n * the album.\n */\nexport async function removeAssetsFromAlbumAsync(\n  assets: AssetRef[] | AssetRef,\n  album: AlbumRef\n): Promise<boolean> {\n  if (!MediaLibrary.removeAssetsFromAlbumAsync) {\n    throw new UnavailabilityError('MediaLibrary', 'removeAssetsFromAlbumAsync');\n  }\n\n  const assetIds = arrayize(assets).map(getId);\n  const albumId = getId(album);\n\n  checkAssetIds(assetIds);\n  return await MediaLibrary.removeAssetsFromAlbumAsync(assetIds, albumId);\n}\n\n// @needsAudit\n/**\n * Deletes assets from the library. On iOS it deletes assets from all albums they belong to, while\n * on Android it keeps all copies of them (album is strictly connected to the asset). Also, there is\n * additional dialog on iOS that requires user to confirm this action.\n * @param assets An array of [Asset](#asset) or their IDs.\n * @return Returns promise which fulfils with `true` if the assets were successfully deleted.\n */\nexport async function deleteAssetsAsync(assets: AssetRef[] | AssetRef): Promise<boolean> {\n  if (!MediaLibrary.deleteAssetsAsync) {\n    throw new UnavailabilityError('MediaLibrary', 'deleteAssetsAsync');\n  }\n\n  const assetIds = arrayize(assets).map(getId);\n\n  checkAssetIds(assetIds);\n  return await MediaLibrary.deleteAssetsAsync(assetIds);\n}\n\n// @needsAudit\n/**\n * Provides more information about an asset, including GPS location, local URI and EXIF metadata.\n * @param asset An [Asset](#asset) or its ID.\n * @param options\n * @return [AssetInfo](#assetinfo) object, which is an `Asset` extended by an additional fields.\n */\nexport async function getAssetInfoAsync(\n  asset: AssetRef,\n  options: MediaLibraryAssetInfoQueryOptions = { shouldDownloadFromNetwork: true }\n): Promise<AssetInfo> {\n  if (!MediaLibrary.getAssetInfoAsync) {\n    throw new UnavailabilityError('MediaLibrary', 'getAssetInfoAsync');\n  }\n\n  const assetId = getId(asset);\n\n  checkAssetIds([assetId]);\n\n  const assetInfo = await MediaLibrary.getAssetInfoAsync(assetId, options);\n\n  if (Array.isArray(assetInfo)) {\n    // Android returns an array with asset info, we need to pick the first item\n    return assetInfo[0];\n  }\n  return assetInfo;\n}\n\n// @needsAudit\n/**\n * Queries for user-created albums in media gallery.\n * @return A promise which fulfils with an array of [`Album`](#asset)s. Depending on Android version,\n * root directory of your storage may be listed as album titled `\"0\"` or unlisted at all.\n */\nexport async function getAlbumsAsync({ includeSmartAlbums = false }: AlbumsOptions = {}): Promise<\n  Album[]\n> {\n  if (!MediaLibrary.getAlbumsAsync) {\n    throw new UnavailabilityError('MediaLibrary', 'getAlbumsAsync');\n  }\n  return await MediaLibrary.getAlbumsAsync({ includeSmartAlbums });\n}\n\n// @needsAudit\n/**\n * Queries for an album with a specific name.\n * @param title Name of the album to look for.\n * @return An object representing an [`Album`](#album), if album with given name exists, otherwise\n * returns `null`.\n */\nexport async function getAlbumAsync(title: string): Promise<Album> {\n  if (!MediaLibrary.getAlbumAsync) {\n    throw new UnavailabilityError('MediaLibrary', 'getAlbumAsync');\n  }\n  if (typeof title !== 'string') {\n    throw new Error('Album title must be a string!');\n  }\n  return await MediaLibrary.getAlbumAsync(title);\n}\n\n// @needsAudit\n/**\n * Creates an album with given name and initial asset. The asset parameter is required on Android,\n * since it's not possible to create empty album on this platform. On Android, by default it copies\n * given asset from the current album to the new one, however it's also possible to move it by\n * passing `false` as `copyAsset` argument.\n * In case it's copied you should keep in mind that `getAssetsAsync` will return duplicated asset.\n * @param albumName Name of the album to create.\n * @param asset An [Asset](#asset) or its ID (required on Android).\n * @param copyAsset __Android Only.__ Whether to copy asset to the new album instead of move it.\n * Defaults to `true`.\n * @return Newly created [`Album`](#album).\n */\nexport async function createAlbumAsync(\n  albumName: string,\n  asset?: AssetRef,\n  copyAsset: boolean = true\n): Promise<Album> {\n  if (!MediaLibrary.createAlbumAsync) {\n    throw new UnavailabilityError('MediaLibrary', 'createAlbumAsync');\n  }\n\n  const assetId = getId(asset);\n\n  if (Platform.OS === 'android' && (typeof assetId !== 'string' || assetId.length === 0)) {\n    // it's not possible to create empty album on Android, so initial asset must be provided\n    throw new Error('MediaLibrary.createAlbumAsync must be called with an asset on Android.');\n  }\n  if (!albumName || typeof albumName !== 'string') {\n    throw new Error('Invalid argument \"albumName\". It must be a string!');\n  }\n  if (assetId != null && typeof assetId !== 'string') {\n    throw new Error('Asset ID must be a string!');\n  }\n\n  if (Platform.OS === 'ios') {\n    return await MediaLibrary.createAlbumAsync(albumName, assetId);\n  }\n  return await MediaLibrary.createAlbumAsync(albumName, assetId, !!copyAsset);\n}\n\n// @needsAudit\n/**\n * Deletes given albums from the library. On Android by default it deletes assets belonging to given\n * albums from the library. On iOS it doesn't delete these assets, however it's possible to do by\n * passing `true` as `deleteAssets`.\n * @param albums An array of [`Album`](#asset)s or their IDs.\n * @param assetRemove __iOS Only.__ Whether to also delete assets belonging to given albums.\n * Defaults to `false`.\n * @return Returns a promise which fulfils with `true` if the albums were successfully deleted from\n * the library.\n */\nexport async function deleteAlbumsAsync(\n  albums: AlbumRef[] | AlbumRef,\n  assetRemove: boolean = false\n): Promise<boolean> {\n  if (!MediaLibrary.deleteAlbumsAsync) {\n    throw new UnavailabilityError('MediaLibrary', 'deleteAlbumsAsync');\n  }\n\n  const albumIds = arrayize(albums).map(getId);\n\n  checkAlbumIds(albumIds);\n  if (Platform.OS === 'android') {\n    return await MediaLibrary.deleteAlbumsAsync(albumIds);\n  }\n  return await MediaLibrary.deleteAlbumsAsync(albumIds, !!assetRemove);\n}\n\n// @needsAudit\n/**\n * Fetches a page of assets matching the provided criteria.\n * @param assetsOptions\n * @return A promise that fulfils with to [`PagedInfo`](#pagedinfo) object with array of [`Asset`](#asset)s.\n */\nexport async function getAssetsAsync(assetsOptions: AssetsOptions = {}): Promise<PagedInfo<Asset>> {\n  if (!MediaLibrary.getAssetsAsync) {\n    throw new UnavailabilityError('MediaLibrary', 'getAssetsAsync');\n  }\n\n  const { first, after, album, sortBy, mediaType, createdAfter, createdBefore } = assetsOptions;\n\n  const options = {\n    first: first == null ? 20 : first,\n    after: getId(after),\n    album: getId(album),\n    sortBy: arrayize(sortBy),\n    mediaType: arrayize(mediaType || [MediaType.photo]),\n    createdAfter: dateToNumber(createdAfter),\n    createdBefore: dateToNumber(createdBefore),\n  };\n\n  if (first != null && typeof options.first !== 'number') {\n    throw new Error('Option \"first\" must be a number!');\n  }\n  if (after != null && typeof options.after !== 'string') {\n    throw new Error('Option \"after\" must be a string!');\n  }\n  if (album != null && typeof options.album !== 'string') {\n    throw new Error('Option \"album\" must be a string!');\n  }\n\n  if (after != null && Platform.OS === 'android' && isNaN(parseInt(getId(after) as string, 10))) {\n    throw new Error('Option \"after\" must be a valid ID!');\n  }\n\n  if (first != null && first < 0) {\n    throw new Error('Option \"first\" must be a positive integer!');\n  }\n\n  options.sortBy.forEach(checkSortBy);\n  options.mediaType.forEach(checkMediaType);\n\n  return await MediaLibrary.getAssetsAsync(options);\n}\n\n// @needsAudit\n/**\n * Subscribes for updates in user's media library.\n * @param listener A callback that is fired when any assets have been inserted or deleted from the\n * library, or when the user changes which assets they're allowing access to. On Android it's\n * invoked with an empty object. On iOS it's invoked with [`MediaLibraryAssetsChangeEvent`](#medialibraryassetschangeevent)\n * object.\n * @return An [`Subscription`](#subscription) object that you can call `remove()` on when you would\n * like to unsubscribe the listener.\n */\nexport function addListener(\n  listener: (event: MediaLibraryAssetsChangeEvent) => void\n): Subscription {\n  return eventEmitter.addListener(MediaLibrary.CHANGE_LISTENER_NAME, listener);\n}\n\n// @docsMissing\nexport function removeSubscription(subscription: Subscription): void {\n  subscription.remove();\n}\n\n// @needsAudit\n/**\n * Removes all listeners.\n */\nexport function removeAllListeners(): void {\n  eventEmitter.removeAllListeners(MediaLibrary.CHANGE_LISTENER_NAME);\n}\n\n// @needsAudit\n/**\n * Fetches a list of moments, which is a group of assets taken around the same place\n * and time.\n * @return An array of [albums](#album) whose type is `moment`.\n * @platform ios\n */\nexport async function getMomentsAsync() {\n  if (!MediaLibrary.getMomentsAsync) {\n    throw new UnavailabilityError('MediaLibrary', 'getMomentsAsync');\n  }\n\n  return await MediaLibrary.getMomentsAsync();\n}\n\n// @needsAudit\n/**\n * Moves album content to the special media directories on **Android R** or **above** if needed.\n * Those new locations are in line with the Android `scoped storage` - so your application won't\n * lose write permission to those directories in the future.\n *\n * This method does nothing if:\n * - app is running on **iOS**, **web** or **Android below R**\n * - app has **write permission** to the album folder\n *\n * The migration is possible when the album contains only compatible files types.\n * For instance, movies and pictures are compatible with each other, but music and pictures are not.\n * If automatic migration isn't possible, the function will be rejected.\n * In that case, you can use methods from the `expo-file-system` to migrate all your files manually.\n *\n * # Why do you need to migrate files?\n * __Android R__ introduced a lot of changes in the storage system. Now applications can't save\n * anything to the root directory. The only available locations are from the `MediaStore` API.\n * Unfortunately, the media library stored albums in folders for which, because of those changes,\n * the application doesn't have permissions anymore. However, it doesn't mean you need to migrate\n * all your albums. If your application doesn't add assets to albums, you don't have to migrate.\n * Everything will work as it used to. You can read more about scoped storage in [the Android documentation](https://developer.android.com/about/versions/11/privacy/storage).\n *\n * @param album An [Album](#album) or its ID.\n * @return A promise which fulfils to `void`.\n */\nexport async function migrateAlbumIfNeededAsync(album: AlbumRef): Promise<void> {\n  if (!MediaLibrary.migrateAlbumIfNeededAsync) {\n    return;\n  }\n\n  return await MediaLibrary.migrateAlbumIfNeededAsync(getId(album));\n}\n\n// @needsAudit\n/**\n * Checks if the album should be migrated to a different location. In other words, it checks if the\n * application has the write permission to the album folder. If not, it returns `true`, otherwise `false`.\n * > Note: For **Android below R**, **web** or **iOS**, this function always returns `false`.\n * @param album An [Album](#album) or its ID.\n * @return Returns a promise which fulfils with `true` if the album should be migrated.\n */\nexport async function albumNeedsMigrationAsync(album: AlbumRef): Promise<boolean> {\n  if (!MediaLibrary.albumNeedsMigrationAsync) {\n    return false;\n  }\n\n  return await MediaLibrary.albumNeedsMigrationAsync(getId(album));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}